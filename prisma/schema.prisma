// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}
datasource db {
  provider = "postgresql"
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String?
  firstName    String?
  lastName     String?
  phone        String?
  
  // Email verification
  emailVerified Boolean @default(false)
  emailVerifiedAt DateTime?
  
  // RBAC - Role-based access control
  roleId       String
  role         Role     @relation(fields: [roleId], references: [id])

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // relationships
  sessions     Session[]
  appointments Appointment[]
  doctorProfile Doctor?
  prescriptions Prescription[]
  doctorApplication DoctorApplication?
  passwordResetTokens PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]
  refreshTokens RefreshToken[]
  medicalRecords MedicalRecord[]
  healthProfile PatientHealthProfile?

  @@index([email])
  @@map("users")
}

model Role {
  id          String       @id @default(cuid())
  name        String       @unique // "admin", "doctor", "patient"
  description String?
  permissions Permission[]
  users       User[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@map("roles")
}

model Permission {
  id          String   @id @default(cuid())
  name        String   @unique // "appointment:create", "user:read"
  description String?
  roles       Role[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("permissions")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@map("sessions")
}

model Doctor {
  id         String   @id @default(cuid())
  userId     String?  @unique // Link to User if doctor is a registered user
  name       String
  email      String   @unique
  phone      String
  speciality String
  bio        String?
  imageUrl   String
  gender     Gender
  isVerified Boolean  @default(false) // Admin verification status
  
  // Location for location-based search
  address    String?
  city       String?
  state      String?
  country    String?  @default("United States")
  zipCode    String?
  latitude   Decimal? // For geo-based search
  longitude  Decimal? // For geo-based search
  
  // Ratings
  rating         Decimal  @default(0) // Average rating (0-5)
  totalReviews   Int      @default(0) // Number of reviews
  
  // Additional info
  yearsOfExperience Int?
  education         String? // JSON array of education
  certifications    String? // JSON array of certifications
  languages         String? // JSON array of languages spoken
  consultationFee   Decimal? // Base consultation fee
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // relationships
  user             User?                   @relation(fields: [userId], references: [id], onDelete: SetNull)
  appointments     Appointment[]
  availability     DoctorAvailability?
  appointmentTypes DoctorAppointmentType[]
  workingHours     DoctorWorkingHours[]
  verification     DoctorVerification?
  paymentAccount   DoctorPaymentAccount? // Stripe Connect account
  payments         AppointmentPayment[] // Payment records
  prescriptions    Prescription[] // Prescriptions issued by this doctor
  reviews          DoctorReview[] // Reviews from patients

  @@index([speciality])
  @@index([isVerified, createdAt])
  @@index([email])
  @@index([city, state])
  @@index([rating])
  @@map("doctors")
}

// Doctor Reviews from Patients
model DoctorReview {
  id          String   @id @default(cuid())
  doctorId    String
  doctor      Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patientId   String
  appointmentId String? @unique // Link to specific appointment
  
  rating      Int      // 1-5 stars
  title       String?
  comment     String?
  
  // Moderation
  isVerified  Boolean  @default(false) // Verified purchase/appointment
  isPublished Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([doctorId, createdAt])
  @@index([patientId])
  @@map("doctor_reviews")
}

model DoctorAvailability {
  id       String @id @default(cuid())
  doctorId String @unique
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Time slots available (stored as JSON array of time strings)
  timeSlots String // JSON array: ["09:00", "09:30", ...]

  // Booking settings
  slotDuration       Int @default(30) // minutes per slot
  bookingAdvanceDays Int @default(30) // days in advance patients can book
  minBookingHours    Int @default(24) // minimum hours before appointment

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("doctor_availability")
}

model DoctorWorkingHours {
  id       String @id @default(cuid())
  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  dayOfWeek Int // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  startTime String // e.g., "09:00"
  endTime   String // e.g., "17:00"
  isWorking Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([doctorId, dayOfWeek])
  @@map("doctor_working_hours")
}

model DoctorAppointmentType {
  id       String @id @default(cuid())
  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  name        String // e.g., "Regular Checkup", "Teeth Cleaning"
  duration    Int // duration in minutes
  description String?
  price       Decimal? // optional price

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("doctor_appointment_types")
}

model Appointment {
  id                String            @id @default(cuid())
  date              DateTime
  time              String // store time as string i.e. 14:30
  duration          Int // duration in minutes (from appointment type or doctor default)
  status            AppointmentStatus @default(PENDING) // Changed from CONFIRMED to PENDING
  notes             String?
  reason            String? // reason for appointment - teeth cleaning? emergency visit? etc.
  appointmentTypeId String? // Link to doctor's appointment type
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // foreign keys
  userId   String
  doctorId String

  // relationships
  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  doctor       Doctor              @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  payment      AppointmentPayment? // Payment record for this appointment
  prescription Prescription? // Prescription linked to this appointment

  @@index([date])
  @@index([status, doctorId])
  @@index([status, userId])
  @@index([date, doctorId])
  @@map("appointments")
}

enum Gender {
  MALE
  FEMALE
}

enum AppointmentStatus {
  PENDING // Awaiting doctor confirmation
  CONFIRMED // Confirmed by doctor
  COMPLETED // Appointment completed
  CANCELLED // Cancelled by patient or doctor
}

enum ApplicationStatus {
  PENDING // Application submitted, awaiting review
  APPROVED // Approved by admin
  REJECTED // Rejected by admin
}

model DoctorVerification {
  id       String @id @default(cuid())
  doctorId String @unique
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Document URLs (stored in cloud storage or file system)
  licenseUrl     String? // Medical license document
  certificateUrl String? // Professional certificate
  idDocumentUrl  String? // ID document
  otherDocuments String? // JSON array of additional document URLs

  // Verification status
  status          VerificationStatus @default(PENDING)
  submittedAt     DateTime?
  reviewedAt      DateTime?
  reviewedBy      String? // Admin user ID who reviewed
  rejectionReason String? // If rejected, reason for rejection

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("doctor_verifications")
}

enum VerificationStatus {
  PENDING // Documents submitted, awaiting review
  APPROVED // Approved by admin
  REJECTED // Rejected by admin
}

// Payment System Models

model AppointmentPayment {
  id            String      @id @default(cuid())
  appointmentId String      @unique
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Payment amounts
  appointmentPrice     Decimal // Original appointment price (what patient pays)
  commissionAmount     Decimal // Platform commission
  commissionPercentage Decimal // Commission % used at time of booking
  doctorPayoutAmount   Decimal // Amount doctor receives (appointmentPrice - commissionAmount)

  // Patient payment
  patientPaid           Boolean   @default(false)
  patientPaidAt         DateTime?
  stripePaymentIntentId String?   @unique
  stripeChargeId        String?   @unique

  // Doctor payout
  doctorPaid        Boolean   @default(false)
  doctorPaidAt      DateTime?
  stripeTransferId  String?   @unique
  payoutScheduledAt DateTime? // When payout is scheduled

  // Payment status
  status PaymentStatus @default(PENDING)

  // Refund tracking
  refunded       Boolean     @default(false)
  refundAmount   Decimal?
  refundReason   String?
  refundedAt     DateTime?
  stripeRefundId String?
  refundType     RefundType?

  // Relations
  refunds PaymentRefund[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([doctorId, createdAt])
  @@index([status, createdAt])
  @@map("appointment_payments")
}

model DoctorPaymentAccount {
  id       String @id @default(cuid())
  doctorId String @unique
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Stripe Connect account
  stripeAccountId String              @unique
  accountStatus   StripeAccountStatus @default(PENDING)

  // Onboarding
  onboardingLink          String?
  onboardingLinkExpiresAt DateTime?
  onboardingCompleted     Boolean   @default(false)

  // Account details
  email    String?
  country  String?
  currency String? @default("usd")

  // Payout settings
  payoutEnabled  Boolean @default(false)
  payoutSchedule String? // e.g., "daily", "weekly", "monthly"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("doctor_payment_accounts")
}

model PlatformSettings {
  id String @id @default(cuid())

  // Commission settings
  commissionPercentage Decimal  @default(3.0) // Default 3%
  minCommission        Decimal? // Optional minimum commission amount
  maxCommission        Decimal? // Optional maximum commission amount

  // Settings metadata
  updatedBy String? // Admin user ID who updated
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  @@map("platform_settings")
}

model PaymentRefund {
  id        String             @id @default(cuid())
  paymentId String
  payment   AppointmentPayment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  // Refund details
  amount                 Decimal
  refundType             RefundType
  reason                 String
  hoursBeforeAppointment Int? // Hours before appointment when refunded

  // Stripe refund
  stripeRefundId String?  @unique
  refundedAt     DateTime @default(now())

  // Status
  status RefundStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([paymentId])
  @@map("payment_refunds")
}

enum PaymentStatus {
  PENDING // Payment initiated, awaiting completion
  PROCESSING // Payment being processed
  COMPLETED // Payment successful
  FAILED // Payment failed
  REFUNDED // Payment refunded
  PARTIALLY_REFUNDED // Partial refund
}

enum RefundType {
  FULL // Full refund
  PARTIAL // Partial refund
  COMMISSION_ONLY // Only commission refunded
  NO_REFUND // No refund (no-show, etc.)
}

enum RefundStatus {
  PENDING // Refund initiated
  PROCESSING // Refund being processed
  COMPLETED // Refund completed
  FAILED // Refund failed
}

enum StripeAccountStatus {
  PENDING // Account creation pending
  RESTRICTED // Account restricted (needs verification)
  ACTIVE // Account active and ready
  REJECTED // Account rejected
}

// Prescription System Models

model Prescription {
  id           String             @id @default(cuid())
  appointmentId String?            @unique // Link to appointment (optional for standalone prescriptions)
  appointment  Appointment?       @relation(fields: [appointmentId], references: [id], onDelete: SetNull)
  
  doctorId     String
  doctor       Doctor             @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  
  patientId    String
  patient      User               @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  status       PrescriptionStatus @default(ACTIVE)
  issueDate    DateTime           @default(now())
  expiryDate   DateTime? // Optional expiry date
  notes        String? // Additional notes from doctor
  
  // Relationships
  items        PrescriptionItem[]
  audits       PrescriptionAudit[]
  
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  
  @@index([doctorId, createdAt])
  @@index([patientId, createdAt])
  @@index([status, createdAt])
  @@index([appointmentId])
  @@map("prescriptions")
}

model PrescriptionItem {
  id                String      @id @default(cuid())
  prescriptionId   String
  prescription      Prescription @relation(fields: [prescriptionId], references: [id], onDelete: Cascade)
  
  medicationId      String? // Link to medication database (optional)
  medication        Medication? @relation(fields: [medicationId], references: [id], onDelete: SetNull)
  
  medicationName    String // Medication name (stored for reference even if medication is deleted)
  dosage            String // e.g., "500mg", "10ml"
  frequency         String // e.g., "Twice daily", "Every 8 hours"
  duration          String // e.g., "7 days", "2 weeks"
  instructions      String? // Additional instructions
  quantity          Int? // Number of units/pills
  
  refillsAllowed    Int         @default(0) // Number of refills allowed
  refillsRemaining  Int         @default(0) // Number of refills remaining
  
  // Relationships
  refills           PrescriptionRefill[]
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  @@index([prescriptionId])
  @@index([medicationId])
  @@map("prescription_items")
}

model Medication {
  id           String   @id @default(cuid())
  name         String   // Brand name
  genericName  String?  // Generic name
  dosageForms  String   // JSON array: ["tablet", "capsule", "liquid"]
  strengths    String   // JSON array: ["100mg", "250mg", "500mg"]
  description  String?  // Medication description
  isActive     Boolean  @default(true)
  
  // Relationships
  prescriptionItems PrescriptionItem[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([name])
  @@index([genericName])
  @@index([isActive])
  @@map("medications")
}

model PrescriptionRefill {
  id                String      @id @default(cuid())
  prescriptionItemId String
  prescriptionItem  PrescriptionItem @relation(fields: [prescriptionItemId], references: [id], onDelete: Cascade)
  
  requestedAt       DateTime    @default(now())
  requestedBy       String      // Patient user ID
  approvedAt        DateTime?
  approvedBy        String?     // Doctor user ID
  status            RefillStatus @default(PENDING)
  notes             String?     // Notes from patient or doctor
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  @@index([prescriptionItemId])
  @@index([status, requestedAt])
  @@map("prescription_refills")
}

model PrescriptionAudit {
  id            String      @id @default(cuid())
  prescriptionId String
  prescription  Prescription @relation(fields: [prescriptionId], references: [id], onDelete: Cascade)
  
  action        String      // e.g., "CREATED", "UPDATED", "CANCELLED", "ITEM_ADDED", "ITEM_REMOVED"
  changedBy     String      // User ID who made the change
  changes       String?     // JSON object describing what changed
  timestamp     DateTime    @default(now())
  
  @@index([prescriptionId, timestamp])
  @@index([changedBy, timestamp])
  @@map("prescription_audits")
}

enum PrescriptionStatus {
  ACTIVE    // Prescription is active
  EXPIRED   // Prescription has expired
  CANCELLED // Prescription was cancelled
  COMPLETED // All medications completed, no refills remaining
}

enum RefillStatus {
  PENDING   // Refill request pending doctor approval
  APPROVED  // Refill approved by doctor
  REJECTED  // Refill rejected by doctor
  COMPLETED // Refill has been fulfilled
}

// Doctor Application System
model DoctorApplication {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Application details
  speciality    String
  licenseNumber String?
  yearsOfExperience Int?
  bio           String?
  
  // Status
  status        ApplicationStatus @default(PENDING)
  submittedAt   DateTime @default(now())
  reviewedAt    DateTime?
  reviewedBy    String? // Admin user ID who reviewed
  rejectionReason String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([status, submittedAt])
  @@map("doctor_applications")
}

// Password Reset Token
model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())
  
  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

// Email Verification Token
model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  email     String   // Email to verify
  expiresAt DateTime
  verifiedAt DateTime?
  createdAt DateTime @default(now())
  
  @@index([token])
  @@index([userId])
  @@map("email_verification_tokens")
}

// Refresh Token for token rotation
model RefreshToken {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token       String   @unique
  family      String   // Token family for rotation detection
  expiresAt   DateTime
  revokedAt   DateTime?
  replacedBy  String?  // ID of token that replaced this one
  createdAt   DateTime @default(now())
  
  @@index([token])
  @@index([userId])
  @@index([family])
  @@map("refresh_tokens")
}

// Patient Medical History
model MedicalRecord {
  id          String   @id @default(cuid())
  patientId   String
  patient     User     @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  // Record type
  recordType  MedicalRecordType
  
  // Content
  title       String
  description String?
  diagnosis   String?
  treatment   String?
  notes       String?
  
  // Associated appointment (if applicable)
  appointmentId String? @unique
  
  // Document attachments (JSON array of URLs)
  attachments String?
  
  // Metadata
  recordDate  DateTime @default(now())
  createdBy   String   // Doctor or admin who created the record
  updatedBy   String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([patientId, recordDate])
  @@index([patientId, recordType])
  @@map("medical_records")
}

enum MedicalRecordType {
  CONSULTATION
  DIAGNOSIS
  TREATMENT
  LAB_RESULT
  IMAGING
  VACCINATION
  ALLERGY
  SURGERY
  CHRONIC_CONDITION
  MEDICATION
  GENERAL_NOTE
}

// Patient Health Profile (allergies, conditions, etc.)
model PatientHealthProfile {
  id          String   @id @default(cuid())
  patientId   String   @unique
  patient     User     @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  // Basic health info
  bloodType   String?
  height      Decimal? // in cm
  weight      Decimal? // in kg
  dateOfBirth DateTime?
  
  // Health conditions (JSON arrays)
  allergies       String? // JSON array of allergies
  chronicConditions String? // JSON array of chronic conditions
  currentMedications String? // JSON array of medications
  surgicalHistory String? // JSON array of past surgeries
  familyHistory   String? // JSON array of family medical history
  
  // Lifestyle
  smokingStatus   String? // "never", "former", "current"
  alcoholUse      String? // "none", "occasional", "moderate", "heavy"
  exerciseFrequency String? // "none", "rarely", "moderate", "frequent"
  
  // Emergency contact
  emergencyContactName  String?
  emergencyContactPhone String?
  emergencyContactRelation String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("patient_health_profiles")
}
